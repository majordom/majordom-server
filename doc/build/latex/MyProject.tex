% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{My Project Documentation}
\date{April 20, 2014}
\release{0.0.1}
\author{RaphaÃ«l Gautier}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Welcome to our home automation box project!

The RVVDomoticBox project is led by three engineering students at the
French Engineering School Supelec. It aims at designing a versatile
home automaton manager/box written in Python. Its main characteristics
are the following :
\begin{itemize}
\item {} \begin{description}
\item[{\textbf{open-source}}] \leavevmode
We wish that anybody was able to use the base software we developed in order to ensure its continued existence.

\end{description}

\item {} \begin{description}
\item[{\textbf{modularity}}] \leavevmode
The whole app is plugin-based, making it really easy to enhance the base system.

\end{description}

\item {} \begin{description}
\item[{\textbf{simplicity}}] \leavevmode
The choice of Python as the main programming language of the box and the relative simplicity of the software architecture should allow anyone develop plugins.

\end{description}

\end{itemize}

Table of contents :


\chapter{The Project}
\label{the_project:welcome-to-rvvdomoticbox-s-documentation}\label{the_project::doc}\label{the_project:the-project}

\section{Overview}
\label{the_project:overview}

\section{Features}
\label{the_project:features}

\section{Requirements}
\label{the_project:requirements}

\section{Installation}
\label{the_project:installation}

\section{References}
\label{the_project:references}\begin{itemize}
\item {} 
Arduino

\item {} 
Python

\item {} 
pySerial

\item {} 
bitarray

\item {} 
Kivy

\end{itemize}


\chapter{First-steps guide}
\label{first_steps::doc}\label{first_steps:first-steps-guide}

\section{Launching the box for the first time}
\label{first_steps:launching-the-box-for-the-first-time}

\subsection{Basic configuration}
\label{first_steps:basic-configuration}

\subsection{Personnalization}
\label{first_steps:personnalization}

\section{Managing devices}
\label{first_steps:managing-devices}

\subsection{Add a device}
\label{first_steps:add-a-device}

\subsection{Remove a device}
\label{first_steps:remove-a-device}

\section{Scenarios setup}
\label{first_steps:scenarios-setup}

\subsection{Create a new Scenario}
\label{first_steps:create-a-new-scenario}

\subsection{Activate/deactivate a scenario}
\label{first_steps:activate-deactivate-a-scenario}

\chapter{API}
\label{api:api}\label{api::doc}

\section{Kernel}
\label{api/kernel:kernel}\label{api/kernel::doc}\index{Kernel (class in kernel)}

\begin{fulllineitems}
\phantomsection\label{api/kernel:kernel.Kernel}\pysigline{\strong{class }\code{kernel.}\bfcode{Kernel}}
Gathers every plugin installed. 
It centralizes every driver, modem, automation and device 
instantiated in the box to allow each other to communicate.
A plugin is instantiated once when it is loaded, the Kernel 
keeps a reference to it to avoid to load it again.
Drivers, modems and interfaces are also instantiated 
only once when the plugin it comes from is loaded.
Devices are instantiated by the drivers and added to the
Kernel's devices list to make them accessible to every 
other module.
\index{add\_to\_kernel() (kernel.Kernel method)}

\begin{fulllineitems}
\phantomsection\label{api/kernel:kernel.Kernel.add_to_kernel}\pysiglinewithargsret{\bfcode{add\_to\_kernel}}{\emph{element}}{}
Adds the element given as argument to the corresponding objects
list of the kernel. It accepts objects whose type is any of the 
followings:
* a python module
* Modem
* Interface
* Device
* Action
* Info
* BlockModel
* Scenario
It auto-detects the type of the argument given and automatically 
appends it to the relevant list.

\end{fulllineitems}

\index{get\_by\_id() (kernel.Kernel method)}

\begin{fulllineitems}
\phantomsection\label{api/kernel:kernel.Kernel.get_by_id}\pysiglinewithargsret{\bfcode{get\_by\_id}}{\emph{searched\_id}}{}
If the element whose ID has been given is in one of the
object lists of the kernel, it returns it. If this ID is not 
found, it returns False.

\end{fulllineitems}

\index{get\_new\_id() (kernel.Kernel method)}

\begin{fulllineitems}
\phantomsection\label{api/kernel:kernel.Kernel.get_new_id}\pysiglinewithargsret{\bfcode{get\_new\_id}}{}{}
Returns a unique identifier of type int which can later be used
to reference an object. It is particularly useful when it comes
to user interfaces.

\end{fulllineitems}

\index{load\_plugins() (kernel.Kernel method)}

\begin{fulllineitems}
\phantomsection\label{api/kernel:kernel.Kernel.load_plugins}\pysiglinewithargsret{\bfcode{load\_plugins}}{}{}
Loads all plugins available in the plugin package/subdirectory. 
If a plugin has already been loaded, it is ignored.

\end{fulllineitems}

\index{remove\_by\_id() (kernel.Kernel method)}

\begin{fulllineitems}
\phantomsection\label{api/kernel:kernel.Kernel.remove_by_id}\pysiglinewithargsret{\bfcode{remove\_by\_id}}{\emph{searched\_id}}{}
If the element whose ID has been given is in one of the
object lists of the kernel, it removes it from it and 
returns the removed element. If this ID is not found, 
it returns False.

\end{fulllineitems}


\end{fulllineitems}



\section{Models}
\label{api/models:models}\label{api/models::doc}

\subsection{Information}
\label{api/models:information}\index{Information (class in models)}

\begin{fulllineitems}
\phantomsection\label{api/models:models.Information}\pysiglinewithargsret{\strong{class }\code{models.}\bfcode{Information}}{\emph{name}, \emph{description}, \emph{info\_range}}{}
Class used to wrap an information made available by a device.
\index{set() (models.Information method)}

\begin{fulllineitems}
\phantomsection\label{api/models:models.Information.set}\pysiglinewithargsret{\bfcode{set}}{\emph{args}}{}
Method enabling the user to change the name, the description and
the location of the device. The args must follow the format given in
device\_infos{[}'arguments'{]}.

\end{fulllineitems}


\end{fulllineitems}



\subsection{Action}
\label{api/models:action}\index{Action (class in models)}

\begin{fulllineitems}
\phantomsection\label{api/models:models.Action}\pysiglinewithargsret{\strong{class }\code{models.}\bfcode{Action}}{\emph{name}, \emph{description}, \emph{method}, \emph{arguments\_format}}{}
Class used to wrap an action made available by a device.
\index{set() (models.Action method)}

\begin{fulllineitems}
\phantomsection\label{api/models:models.Action.set}\pysiglinewithargsret{\bfcode{set}}{\emph{args}}{}
Method enabling the user to change the name, the description and
the location of the device. The args must follow the format given in
device\_infos{[}'arguments'{]}.

\end{fulllineitems}


\end{fulllineitems}



\subsection{Device}
\label{api/models:device}\index{Device (class in models)}

\begin{fulllineitems}
\phantomsection\label{api/models:models.Device}\pysiglinewithargsret{\strong{class }\code{models.}\bfcode{Device}}{\emph{protocol}}{}
Base class for any Device.

\end{fulllineitems}



\subsubsection{Implementation examples}
\label{api/models:implementation-examples}

\subsection{Interface}
\label{api/models:interface}\index{Interface (class in models)}

\begin{fulllineitems}
\phantomsection\label{api/models:models.Interface}\pysigline{\strong{class }\code{models.}\bfcode{Interface}}
Base class for any Interface. This class will be documented
later, once an Interface actually behaving like a plugin would
have been developed.

\end{fulllineitems}



\subsubsection{Implementation examples}
\label{api/models:id1}

\subsection{Protocol}
\label{api/models:protocol}\index{Protocol (class in models)}

\begin{fulllineitems}
\phantomsection\label{api/models:models.Protocol}\pysigline{\strong{class }\code{models.}\bfcode{Protocol}}
In the model used to design the box, a class deriving from 
Protocol implements all the functions that are necessary in
order to make the box compatible with a new home automation
protocol. For instance, it is the protocol class of a given home
automation protocol     that should implement the methods necessary 
to the process of adding of a new device to the box.

The class :class:Protocol defines the minimal public 
interface that any protocol class should implement, in order 
to allow other entities to use it.  
It should \textbf{not} be directly instantiated.
Any protocol plugin should derive from it. To see what the actual
implementation of a protocol looks like, you may for instance refer
to the classes :class:Nexa and :class:Oregon.

\end{fulllineitems}



\subsubsection{Implementation examples}
\label{api/models:id2}
Example of implementation can be found here: {\hyperref[implementation_examples:protocols.nexa.Nexa]{\code{protocols.nexa.Nexa}}} or {\hyperref[implementation_examples:protocols.oregon.Oregon]{\code{protocols.oregon.Oregon}}}.


\subsection{Driver}
\label{api/models:driver}\index{Driver (class in models)}

\begin{fulllineitems}
\phantomsection\label{api/models:models.Driver}\pysigline{\strong{class }\code{models.}\bfcode{Driver}}
In the model used to design the box, a class deriving from 
Driver implements the way the box communicates with an external
hardware part. Hardware parts may for instance be radio modems, 
as it is the case with the :class:ArduinoRadio driver.
In the case of the hardware being a modem, this class has then
two main features to implement: the process of receiving a 
message and the process of sending one.
In the first case, the driver must implement the way it 
communicates with hardware parts. For the example of the
:class:ArduinoRadio, the mini communication protocol used is 
described in the :doc:'documentation of the Arduino C program \textless{}arduino\_radio\textgreater{}'
Once the message has been recovered from the hardware part,
it must be transmitted to the protocols that use this 
hardware as a communication medium. This is implemented
through a `subscription' process: protocols subscribe to 
the driver they want to get their messages from when
they are initialized.

The class :class:Driver defines the minimal public 
interface that any driver class should implement, in order 
to allow other entities to use it.  
It should \textbf{not} be directly instantiated.
Any driver plugin should derive from it. To see what the actual
implementation of a drivers looks like, you may for instance refer
to the class :class:ArduinoRadio.

\end{fulllineitems}



\subsubsection{Implementation examples}
\label{api/models:id3}
An example of implementation can be found here: :class:drivers.arduino\_radio.ArduinoRadio.


\section{Scenario}
\label{api/scenario::doc}\label{api/scenario:scenario}

\subsection{Scenarios}
\label{api/scenario:scenarios}\index{Scenario (class in scenario)}

\begin{fulllineitems}
\phantomsection\label{api/scenario:scenario.Scenario}\pysigline{\strong{class }\code{scenario.}\bfcode{Scenario}}
Base class for any Scenario.
A scenario has a list of blocks and a list of links. 
Blocks and links each have an ID which is unique (a block and
a link can't either have the same ID) within a scenario and
makes easier the reference to them. This ID is gotten from
the get\_new\_id method when the object is added to the 
Scenario.
\index{activate() (scenario.Scenario method)}

\begin{fulllineitems}
\phantomsection\label{api/scenario:scenario.Scenario.activate}\pysiglinewithargsret{\bfcode{activate}}{}{}
Activates this scenario, i.e. the links between ports
of blocks become active: they are translated into 
observer-observed relationships.

\end{fulllineitems}

\index{add\_block() (scenario.Scenario method)}

\begin{fulllineitems}
\phantomsection\label{api/scenario:scenario.Scenario.add_block}\pysiglinewithargsret{\bfcode{add\_block}}{\emph{new\_block}}{}
Adds the block given as argument to the scenario 
and returns its ID within the scenario.

\end{fulllineitems}

\index{add\_link() (scenario.Scenario method)}

\begin{fulllineitems}
\phantomsection\label{api/scenario:scenario.Scenario.add_link}\pysiglinewithargsret{\bfcode{add\_link}}{\emph{src\_block\_id}, \emph{src\_port\_id}, \emph{dst\_block\_id}, \emph{dst\_port\_id}}{}
Adds a link from the source port of the source block 
to the destination port of the destination block given 
as arguments.
The blocks and ports are referenced by their respective IDs. 
Returns the id of the new link.

\end{fulllineitems}

\index{deactivate() (scenario.Scenario method)}

\begin{fulllineitems}
\phantomsection\label{api/scenario:scenario.Scenario.deactivate}\pysiglinewithargsret{\bfcode{deactivate}}{}{}
Deactivates this scenario, i. e. resets all the 
observer-observed relationships previously set.

\end{fulllineitems}

\index{get\_new\_id() (scenario.Scenario method)}

\begin{fulllineitems}
\phantomsection\label{api/scenario:scenario.Scenario.get_new_id}\pysiglinewithargsret{\bfcode{get\_new\_id}}{}{}
Returns an unique identifier in order to reference
blocks and links within a scenario.

\end{fulllineitems}

\index{remove\_block() (scenario.Scenario method)}

\begin{fulllineitems}
\phantomsection\label{api/scenario:scenario.Scenario.remove_block}\pysiglinewithargsret{\bfcode{remove\_block}}{\emph{block\_id}}{}
Removes the block whose ID has been specified from
the list of blocks of this Scenario and returns the Block.
If the ID is not found, the method returns False.

\end{fulllineitems}

\index{remove\_link() (scenario.Scenario method)}

\begin{fulllineitems}
\phantomsection\label{api/scenario:scenario.Scenario.remove_link}\pysiglinewithargsret{\bfcode{remove\_link}}{\emph{link\_id}}{}
Removes the link whose ID has been specified from
the list of links of this Scenario and returns the Link.
If the ID is not found, the method returns False.

\end{fulllineitems}


\end{fulllineitems}



\subsection{Blocks}
\label{api/scenario:blocks}\index{Block (class in scenario)}

\begin{fulllineitems}
\phantomsection\label{api/scenario:scenario.Block}\pysigline{\strong{class }\code{scenario.}\bfcode{Block}}
\end{fulllineitems}

\index{SimpleBlock (class in scenario)}

\begin{fulllineitems}
\phantomsection\label{api/scenario:scenario.SimpleBlock}\pysigline{\strong{class }\code{scenario.}\bfcode{SimpleBlock}}
\end{fulllineitems}

\index{CompositeBlock (class in scenario)}

\begin{fulllineitems}
\phantomsection\label{api/scenario:scenario.CompositeBlock}\pysigline{\strong{class }\code{scenario.}\bfcode{CompositeBlock}}
\end{fulllineitems}



\subsubsection{Nodes}
\label{api/scenario:nodes}\index{Node (class in scenario)}

\begin{fulllineitems}
\phantomsection\label{api/scenario:scenario.Node}\pysiglinewithargsret{\strong{class }\code{scenario.}\bfcode{Node}}{\emph{name}, \emph{value\_type}}{}
\end{fulllineitems}

\index{SimpleNode (class in scenario)}

\begin{fulllineitems}
\phantomsection\label{api/scenario:scenario.SimpleNode}\pysiglinewithargsret{\strong{class }\code{scenario.}\bfcode{SimpleNode}}{\emph{name}, \emph{value\_type}}{}
\end{fulllineitems}

\index{CompositeNode (class in scenario)}

\begin{fulllineitems}
\phantomsection\label{api/scenario:scenario.CompositeNode}\pysiglinewithargsret{\strong{class }\code{scenario.}\bfcode{CompositeNode}}{\emph{name}, \emph{value\_type}}{}
\end{fulllineitems}



\subsection{Links}
\label{api/scenario:links}\index{Link (class in scenario)}

\begin{fulllineitems}
\phantomsection\label{api/scenario:scenario.Link}\pysigline{\strong{class }\code{scenario.}\bfcode{Link}}
\end{fulllineitems}



\subsection{Basic types of blocks}
\label{api/scenario:basic-types-of-blocks}\index{Constant (class in scenario)}

\begin{fulllineitems}
\phantomsection\label{api/scenario:scenario.Constant}\pysiglinewithargsret{\strong{class }\code{scenario.}\bfcode{Constant}}{\emph{value}}{}
\end{fulllineitems}

\index{Not (class in scenario)}

\begin{fulllineitems}
\phantomsection\label{api/scenario:scenario.Not}\pysigline{\strong{class }\code{scenario.}\bfcode{Not}}
\end{fulllineitems}

\index{And (class in scenario)}

\begin{fulllineitems}
\phantomsection\label{api/scenario:scenario.And}\pysigline{\strong{class }\code{scenario.}\bfcode{And}}
\end{fulllineitems}

\index{Or (class in scenario)}

\begin{fulllineitems}
\phantomsection\label{api/scenario:scenario.Or}\pysigline{\strong{class }\code{scenario.}\bfcode{Or}}
\end{fulllineitems}

\index{Multiply (class in scenario)}

\begin{fulllineitems}
\phantomsection\label{api/scenario:scenario.Multiply}\pysigline{\strong{class }\code{scenario.}\bfcode{Multiply}}
\end{fulllineitems}



\chapter{Implementation examples}
\label{implementation_examples::doc}\label{implementation_examples:implementation-examples}

\section{Protocols}
\label{implementation_examples:protocols}

\subsection{Nexa}
\label{implementation_examples:nexa}\index{Nexa (class in protocols.nexa)}

\begin{fulllineitems}
\phantomsection\label{implementation_examples:protocols.nexa.Nexa}\pysiglinewithargsret{\strong{class }\code{protocols.nexa.}\bfcode{Nexa}}{\emph{kernel}}{}
Main class of a protocol plugin.
\index{add\_device() (protocols.nexa.Nexa method)}

\begin{fulllineitems}
\phantomsection\label{implementation_examples:protocols.nexa.Nexa.add_device}\pysiglinewithargsret{\bfcode{add\_device}}{\emph{device\_id}, \emph{args}}{}
Proxy method used to instantiate a new device. It raises a 
ValueError if the device\_id given is out of range. It may raise 
a TypeError if the args given to set the new device don't match 
the settings format.

\end{fulllineitems}

\index{decode\_sequence() (protocols.nexa.Nexa method)}

\begin{fulllineitems}
\phantomsection\label{implementation_examples:protocols.nexa.Nexa.decode_sequence}\pysiglinewithargsret{\bfcode{decode\_sequence}}{\emph{sequence}}{}
Processes a radio sequence received by the radio modem 
into a message understable by the protocol.
The implementation of the sequence processing is , for the
moment, a hard-coded finite-state machine.

\end{fulllineitems}

\index{get\_devices() (protocols.nexa.Nexa method)}

\begin{fulllineitems}
\phantomsection\label{implementation_examples:protocols.nexa.Nexa.get_devices}\pysiglinewithargsret{\bfcode{get\_devices}}{}{}
Returns the list of devices that are currently handled 
by this protocol.

\end{fulllineitems}

\index{get\_instantiable\_devices() (protocols.nexa.Nexa method)}

\begin{fulllineitems}
\phantomsection\label{implementation_examples:protocols.nexa.Nexa.get_instantiable_devices}\pysiglinewithargsret{\bfcode{get\_instantiable\_devices}}{}{}
Returns a list of the devices instantiable by the user
of the driver. 
The list of user-instantiable devices is included in the 
list of the driver-handled devices but not necessarily 
equal.

\end{fulllineitems}

\index{get\_set\_arguments() (protocols.nexa.Nexa method)}

\begin{fulllineitems}
\phantomsection\label{implementation_examples:protocols.nexa.Nexa.get_set_arguments}\pysiglinewithargsret{\bfcode{get\_set\_arguments}}{}{}
Returns the arguments needed to set the driver.

\end{fulllineitems}

\index{send\_command() (protocols.nexa.Nexa method)}

\begin{fulllineitems}
\phantomsection\label{implementation_examples:protocols.nexa.Nexa.send_command}\pysiglinewithargsret{\bfcode{send\_command}}{\emph{device}, \emph{command}}{}
Method called when a device intends to send a message.
It builds up the Nexa message according to the command 
to be sent and the identity of the sending device.

\end{fulllineitems}

\index{set() (protocols.nexa.Nexa method)}

\begin{fulllineitems}
\phantomsection\label{implementation_examples:protocols.nexa.Nexa.set}\pysiglinewithargsret{\bfcode{set}}{\emph{args}}{}
Sets the driver. It raises a TypeError if the given modem doesn't
match the awaited modem type.

Keyword arguments:
settings -- the dictionary of settings used to set the driver. Its 
format is determined by the function get\_set\_arguments.

\end{fulllineitems}


\end{fulllineitems}



\subsection{Oregon}
\label{implementation_examples:oregon}\index{Oregon (class in protocols.oregon)}

\begin{fulllineitems}
\phantomsection\label{implementation_examples:protocols.oregon.Oregon}\pysiglinewithargsret{\strong{class }\code{protocols.oregon.}\bfcode{Oregon}}{\emph{kernel}}{}
Main class of a protocol plugin.
\index{add\_device() (protocols.oregon.Oregon method)}

\begin{fulllineitems}
\phantomsection\label{implementation_examples:protocols.oregon.Oregon.add_device}\pysiglinewithargsret{\bfcode{add\_device}}{\emph{device\_id}, \emph{args}}{}
Proxy method used to instantiate a new device. It raises a 
ValueError if the device\_id given is out of range. It may raise 
a TypeError if the args given to set the new device don't match 
the settings format.

\end{fulllineitems}

\index{decode\_sequence() (protocols.oregon.Oregon method)}

\begin{fulllineitems}
\phantomsection\label{implementation_examples:protocols.oregon.Oregon.decode_sequence}\pysiglinewithargsret{\bfcode{decode\_sequence}}{\emph{radio\_sequence}}{}
Processes a radio sequence received by the radio modem 
into a message understable by the protocol.
The implementation of the sequence processing is , for the
moment, a hard-coded finite-state machine.

\end{fulllineitems}

\index{get\_devices() (protocols.oregon.Oregon method)}

\begin{fulllineitems}
\phantomsection\label{implementation_examples:protocols.oregon.Oregon.get_devices}\pysiglinewithargsret{\bfcode{get\_devices}}{}{}
Returns the list of devices that are currently handled 
by this protocol.

\end{fulllineitems}

\index{get\_instantiable\_devices() (protocols.oregon.Oregon method)}

\begin{fulllineitems}
\phantomsection\label{implementation_examples:protocols.oregon.Oregon.get_instantiable_devices}\pysiglinewithargsret{\bfcode{get\_instantiable\_devices}}{}{}
Returns a list of the devices instantiable by the user
of the driver. 
The list of user-instantiable devices is included in the 
list of the driver-handled devices but not necessarily 
equal.

\end{fulllineitems}

\index{get\_set\_arguments() (protocols.oregon.Oregon method)}

\begin{fulllineitems}
\phantomsection\label{implementation_examples:protocols.oregon.Oregon.get_set_arguments}\pysiglinewithargsret{\bfcode{get\_set\_arguments}}{}{}
Returns the arguments needed to set the driver.

\end{fulllineitems}

\index{send\_command() (protocols.oregon.Oregon method)}

\begin{fulllineitems}
\phantomsection\label{implementation_examples:protocols.oregon.Oregon.send_command}\pysiglinewithargsret{\bfcode{send\_command}}{\emph{device}, \emph{command}}{}
Method called when a device intends to send a message.
It builds up the Nexa message according to the command 
to be sent and the identity of the sending device.

\end{fulllineitems}

\index{set() (protocols.oregon.Oregon method)}

\begin{fulllineitems}
\phantomsection\label{implementation_examples:protocols.oregon.Oregon.set}\pysiglinewithargsret{\bfcode{set}}{\emph{args}}{}
Sets the driver. It raises a TypeError if the given modem doesn't
match the awaited modem type.

Keyword arguments:
settings -- the dictionary of settings used to set the driver. Its 
format is determined by the function get\_set\_arguments.

\end{fulllineitems}


\end{fulllineitems}



\section{Drivers}
\label{implementation_examples:drivers}

\subsection{Arduino as a 433MHz AM transceiver}
\label{implementation_examples:arduino-as-a-433mhz-am-transceiver}\index{ArduinoRadio (class in drivers.arduino\_radio)}

\begin{fulllineitems}
\phantomsection\label{implementation_examples:drivers.arduino_radio.ArduinoRadio}\pysigline{\strong{class }\code{drivers.arduino\_radio.}\bfcode{ArduinoRadio}}
Class implementing the interface between the computer
running the domotic box and the Arduino, which is used as 
a 433MHz radio modem.
\index{attach() (drivers.arduino\_radio.ArduinoRadio method)}

\begin{fulllineitems}
\phantomsection\label{implementation_examples:drivers.arduino_radio.ArduinoRadio.attach}\pysiglinewithargsret{\bfcode{attach}}{\emph{observer}}{}
Adds the protocol object given as argument
to the list of protocols that receive their messages
through this modem. 
When the modem receives a radio sequence, it will 
send it to the whole list of its observers.

\end{fulllineitems}

\index{format\_arg() (drivers.arduino\_radio.ArduinoRadio method)}

\begin{fulllineitems}
\phantomsection\label{implementation_examples:drivers.arduino_radio.ArduinoRadio.format_arg}\pysiglinewithargsret{\bfcode{format\_arg}}{\emph{binary}}{}
Formats a binary sequence so that it fits the format 
of the parameters of a command sent to the Arduino. This
method is called by the send\_sequence method.

\end{fulllineitems}

\index{get\_modem\_name() (drivers.arduino\_radio.ArduinoRadio method)}

\begin{fulllineitems}
\phantomsection\label{implementation_examples:drivers.arduino_radio.ArduinoRadio.get_modem_name}\pysiglinewithargsret{\bfcode{get\_modem\_name}}{}{}
Returns the name of the modem.

\end{fulllineitems}

\index{get\_modem\_type() (drivers.arduino\_radio.ArduinoRadio method)}

\begin{fulllineitems}
\phantomsection\label{implementation_examples:drivers.arduino_radio.ArduinoRadio.get_modem_type}\pysiglinewithargsret{\bfcode{get\_modem\_type}}{}{}
Returns the type of the modem.

\end{fulllineitems}

\index{get\_set\_arguments() (drivers.arduino\_radio.ArduinoRadio method)}

\begin{fulllineitems}
\phantomsection\label{implementation_examples:drivers.arduino_radio.ArduinoRadio.get_set_arguments}\pysiglinewithargsret{\bfcode{get\_set\_arguments}}{}{}
Returns the dictionary of arguments that
have to be used in order to set this module.

\end{fulllineitems}

\index{notify\_observers() (drivers.arduino\_radio.ArduinoRadio method)}

\begin{fulllineitems}
\phantomsection\label{implementation_examples:drivers.arduino_radio.ArduinoRadio.notify_observers}\pysiglinewithargsret{\bfcode{notify\_observers}}{\emph{sequence}}{}
Notifies all the protocols that are observing this
modem that an incoming radio message has arrived.
The received sequence is given as argument so that each
protocol can handle the decoding.

\end{fulllineitems}

\index{send\_sequence() (drivers.arduino\_radio.ArduinoRadio method)}

\begin{fulllineitems}
\phantomsection\label{implementation_examples:drivers.arduino_radio.ArduinoRadio.send_sequence}\pysiglinewithargsret{\bfcode{send\_sequence}}{\emph{sequence}}{}
Sends the radio sequence given as an argument.

The \emph{sequence} dictionary must have the following format :

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textsf{\relax 
Key
} & \textsf{\relax 
Type
}\\
\hline
number\_of\_repetitions
 & 
int
\\

base\_radio\_pulse\_length\_in\_microseconds
 & 
int
\\

symbol\_1
 & 
binary\_string
\\

symbol\_2
 & 
binary\_string
\\

...
 & 
binary\_string
\\

symbol\_n
 & 
binary\_string
\\

symbol\_coded\_message
 & 
symbols\_list
\\
\hline\end{tabulary}


\end{fulllineitems}

\index{set() (drivers.arduino\_radio.ArduinoRadio method)}

\begin{fulllineitems}
\phantomsection\label{implementation_examples:drivers.arduino_radio.ArduinoRadio.set}\pysiglinewithargsret{\bfcode{set}}{\emph{args}}{}
Sets the serial communication used by the domotic 
box to communicate with the Arduino. If the given COM
port number is not valid (i.e. it raises a SerialException
when we try to open the connection) the method raises 
the same serial.SerialException.

\end{fulllineitems}


\end{fulllineitems}



\chapter{Software running on the Arduino}
\label{arduino::doc}\label{arduino:software-running-on-the-arduino}

\section{Radio reception}
\label{arduino:radio-reception}

\section{Radio transmission}
\label{arduino:radio-transmission}

\section{Communication with the computer}
\label{arduino:communication-with-the-computer}

\chapter{Proprietary protocols documentation}
\label{proprietary_protocols::doc}\label{proprietary_protocols:proprietary-protocols-documentation}

\section{Nexa}
\label{proprietary_protocols:nexa}

\section{Oregon}
\label{proprietary_protocols:oregon}

\chapter{Appendix}
\label{appendix:appendix}\label{appendix::doc}

\section{FAQ}
\label{appendix:faq}

\section{Licence}
\label{appendix:licence}
Indices and tables :
\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{modindex}

\item {} 
\emph{search}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}
